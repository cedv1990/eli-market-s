/**
 * @license S5.js v2.0.0
 * (c) 2015-2018 Sincosoft, Inc. http://sinco.com.co
 * 
 * Creation date: 27/02/2018
 * Last change: 01/03/2018
 *
 * by GoldenBerry
**/

((win, fac) => {

    const o = Object;
    const a = Array;
    const s = String;
    const j = JSON;

    a.prototype.clean = function (d) {
        for (let i = 0; i < this.length; i++) {
            if (this[i] == d) {
                this.splice(i, 1);
                i--;
            }
        }
        return this;
    };

    a.prototype.unique = function () {
        let u = {}, a = [];
        for (let i = 0, l = this.length; i < l; ++i) {
            if (u.hasOwnProperty(this[i])) {
                continue;
            }
            a.push(this[i]);
            u[this[i]] = 1;
        }
        return a;
    };

    a.prototype.contains = function (searchElement /*, fromIndex*/ ) {
        'use strict';
        const O = o(this);
        const len = parseInt(O.length) || 0;
        if (len === 0) {
            return false;
        }
        const n = parseInt(arguments[1]) || 0;
        let k;
        if (n >= 0) {
            k = n;
        } else {
            k = len + n;
            if (k < 0) {k = 0;}
        }
        let currentElement;
        while (k < len) {
            currentElement = O[k];
            if (searchElement === currentElement ||
                (searchElement !== searchElement && currentElement !== currentElement)) {
                return true;
            }
            k++;
        }
        return false;
    };

    const __lists = o.getOwnPropertyNames(win).filter((x) => x.endsWith('List') || x.indexOf('Array') >= 0);

    __lists.forEach((n) => {
        let __type = win[n];
        __type.prototype.stream = function () {
            if (this == void(0) || this === null || !(this instanceof __type))
                throw new TypeError();

            let Iterator = function (a) {
                this.reset = function () {
                    this.value = null;
                    this.index = -1;
                }

                this.next = function () {
                    if (this.index < a.length) {
                        this.index++;
                        this.value = a[this.index];
                        return this.index < a.length;
                    }
                    return false;
                }

                this.reset();
            };

            return new Iterator(this);
        };
    });

    if (!s.prototype.replaceAll) {
        s.prototype.replaceAll = function (rThis, rWith) {
            return this.replace(new RegExp(rThis, 'g'), rWith);
        };
    }

    s.format = s.prototype.format = function () {
        let i = 0, l = 0;
        let str = (typeof this == 'function' && !(i++)) ? arguments[0] : this;

        while (i < arguments.length) {
            str = str.replaceAll('\\{' + l + '\\}', arguments[i]);
            i++; l++;
        }

        return str;
    };

    s.concat = function () {
        return a.prototype.slice.call(arguments).join('');
    };

    s.toAESEncrypt = s.prototype.toAESEncrypt = function () {
        if (typeof CryptoJS === 'undefined') {
            throw new SincoInitializationError('¡Falta la referencia de AES.js!');
        }

        let text = '';
        let key = CryptoJS.enc.Utf8.parse(String.concat(String.fromCharCode(53), String.fromCharCode(49), String.fromCharCode(110),
            String.fromCharCode(99), String.fromCharCode(48), String.fromCharCode(115), String.fromCharCode(111),
            String.fromCharCode(102), String.fromCharCode(116), String.fromCharCode(95), String.fromCharCode(53),
            String.fromCharCode(46), String.fromCharCode(65), String.fromCharCode(46), String.fromCharCode(53),
            String.fromCharCode(46))); //Mismo KEY usado en C#


        let setKey = (k) => {
            let _k = [];
            for (let i = 0; i < k.length; i += 4) {
                if (k[i + 1]) {
                    _k.push(k[i] + k[i + 1]);
                }
            }
            k = new Uint8Array(_k);
            let r = s.fromCharCode.apply(String, k);
            key = CryptoJS.enc.Utf8.parse(r);
        }

        if (typeof (this) == 'function') {
            text = arguments[0];
            if (arguments[1]) {
                setKey(arguments[1]);
            }
        }
        else {
            text = this;
            if (arguments[0]) {
                setKey(arguments[0]);
            }
        }

        const iv = CryptoJS.enc.Utf8.parse(String.concat(String.fromCharCode(95), String.fromCharCode(84), String.fromCharCode(49),
            String.fromCharCode(99), String.fromCharCode(115), String.fromCharCode(124), String.fromCharCode(70),
            String.fromCharCode(111), String.fromCharCode(110), String.fromCharCode(42), String.fromCharCode(53),
            String.fromCharCode(111), String.fromCharCode(95), String.fromCharCode(83), String.fromCharCode(52),
            String.fromCharCode(53))); //Mismo IV usado en C#

        const valorIterar = Math.floor((Math.random() * 9) + 1);

        let iterar = (final, text, key, iv) => {
            let textoCrypto;

            textoCrypto = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(text), key,
                {
                    keySize: 16,
                    iv: iv,
                    mode: CryptoJS.mode.CBC,
                    padding: CryptoJS.pad.Pkcs7
                });
            if (final > 0) {
                return iterar(final - 1, textoCrypto, key, iv);
            } else {
                return textoCrypto;
            }
        }

        return iterar(valorIterar, text, key, iv).toString() + valorIterar;
    };

    j.tryParse = (str) => {
        try {
            return j.parse(str);
        }
        catch (e) {
            return { messageError: e.message };
        }
    };

    /**
     * @name SincoInitializationError
     * 
     * @description Objeto que muestra una excepción al inicializar un objeto de S5/Sinco
     * @param {String} m String para mostrar como mensaje de error
     */
    const SincoInitializationError = function (m) {
        this.name = 'Sinco Initialization Error';
        this.message = m;
    }
    SincoInitializationError.prototype = Error.prototype;
    win['SincoInitializationError'] = SincoInitializationError;

    const s5 = fac(win);

    const def = (n, v) => 
        o.defineProperty(win, n, {
            get: () => v,
            set: (v) => { throw new ReferenceError('¡El elemento no se puede eliminar ni reasignar!') },
            enumerable: false,
            configurable: false
        });

    def('s5', s5);
    def('Sinco', s5);

})(typeof window !== 'undefined' ? window : this, (win) => {

    var CryptoJS = require('s5-js/aes');

    const arr = [];
    const o = Object;
    const s = String;

    const _attribute = function (name, value) {
        if ( !value ) return this.getAttribute(name);
        else {
            this.setAttribute(name, value);
            _dispatch.call(this, 'attribute', { name: name, value: value });
            return this;
        }
    };

    const _insert = function (e, opc) {
        if (Array.isArray(e)) {
            //let orig = this;
            e.forEach((el) => this.appendChild(el));
        }
        else if (typeof opc === 'undefined' || (typeof opc === 'boolean' && !opc)) {
            this.appendChild(e);
        }
        else if (typeof opc === 'number') {
            if (this.childNodes[opc]) {
                this.insertBefore(e, this.childNodes[opc]);
            }
            else {
                this.appendChild(e);
            }
        }
        else {
            this.insertBefore(e, this.firstChild);
        }

        if (this.listeners['insert']) {
            _dispatch.call(this, 'insert');
        }
        return this;
    };

    const _addEvent = function (type, callback) {
        let _this = this;

        if (_this.addEventListener) {
            _this['_' + type] = callback;
            _this.addEventListener(type, callback, false);
        }
        else if (_this.attachEvent) {
            _this['_' + type] = callback;
            _this['e' + type + callback] = callback;
            _this[type + callback] = () => _this['e' + type + callback](win.event);
            _this.attachEvent('on' + type, _this[type + callback]);
        }
        return _this;
    };

    const _removeEvent = function (type, callback) {
        if (this.detachEvent) {
            this.detachEvent('on' + type, this[type + callback]);
            this[type + callback] = null;
        }
        else
            this.removeEventListener(type, callback, false);
        return this;
    };

    const _styles = function (name, value) {
        if (!value)
            return this.style[name];
        else {
            this.style[name] = value;
            return this;
        }
    };

    const _on = function (eventName, listener) {
        if (!this.listeners[eventName]) this.listeners[eventName] = [];
        this.listeners[eventName].push(listener);
    };

    const _off = function (eventName) {
        this.listeners[eventName] = [];
    };

    const _delete = function (ele) {
        let _this = ele || this;
        const _r = s5.extend(_this.cloneNode());
        if (!_this.remove) {
            if (_this.parentElement)
                _this.parentElement.removeChild(_this);
        }
        else
            _this.remove();
        return _r;
    };

    const _dispatch = function (eventName, values) {
        if (this.listeners[eventName]) {
            for (const i = 0; this.listeners[eventName] && i < this.listeners[eventName].length; i++) {
                this.listeners[eventName][i](this, values);
            }
        }
    };

    const __htmlElementsProps = {
        attribute: _attribute,
        insert: _insert,
        addEvent: _addEvent,
        removeEvent: _removeEvent,
        styles: _styles,
        on: _on,
        off: _off,
        dispatch: _dispatch,
        'delete': _delete
    };

    const _fileToBase64 = (f, c) => {
        if (f){
            if (FileReader) {
                if (f instanceof File) {
                    let FR = new FileReader();
                    FR.name = f.name;
                    FR.size = f.size;
                    FR.onload = function (e) {
                        if (c) {
                            c({
                                'name': this.name,
                                'src': e.target.result.split(',').pop(),
                                'kilobytes': this.size
                            });
                        }
                    };
                    FR.readAsDataURL(f);
                }
                else {
                    throw new SincoInitializationError('¡El primer parámetro debe ser de tipo "File"!');
                }
            }
            else {
                throw new SincoInitializationError('¡El navegador no soporta esta funcionalidad!');
            }
        }
    };

    const _map = (obj, iterator) => arr.map.call(obj, iterator);

    const _filter = (obj, iterator) => arr.filter.call(obj, iterator);

    const _reduce = (obj, iterator, memo) => arr.reduce.call(obj, iterator, memo);

    const _extend = (el, opt) => {
        if (!el) return null;
        opt = opt || __htmlElementsProps;

        let extendProps = function (el, opt) {
            for (const n in opt) {
                if (el[n] !== null && typeof el[n] == 'object' && !(el[n] instanceof Array))
                    extendProps(el[n], opt[n]);
                else
                    el[n] = opt[n];
            }
            return el;
        }

        el = extendProps(el, opt);
        el.listeners = el.listeners || {};

        return el;
    };

    const _addStyles = (e, p) => {
        e = s5.extend(e);
        for (const key in p)
            e.styles(key, p[key]);
    };

    const _parseXml = (xmlStr) => {
        if (win.DOMParser) {
            return new win.DOMParser().parseFromString(xmlStr, 'text/xml');
        }
        let xmlDoc = null;
        if (typeof win.ActiveXObject != 'undefined' && !!(xmlDoc = new win.ActiveXObject('Microsoft.XMLDOM'))) {
            xmlDoc.async = 'false';
            xmlDoc.loadXML(xmlStr);
        }
        return xmlDoc;
    };

    let _QueryString = {
        toString: () => {
            let retorno = '',
                sep = '';
            for (const name in s5.QueryString) {
                if (typeof s5.QueryString[name] !== 'function') {
                    retorno += sep + name + '=' + s5.QueryString[name];
                    sep = '&';
                }
            }
            return retorno;
        },
        hasProperties: () => {
            for (const name in s5.QueryString)
                if (typeof s5.QueryString[name] !== 'function')
                    return true;
            return false;
        }
    };

    const _interpolate = (str) => function interpolate(o) {
            return str.replace(/\${([^{}]*)}/g, function (a, b) {
                var r = typeof o[b] == "function" ? o[b]() : o[b];
                return typeof r === 'string' || typeof r === 'number' ? r : a;
            });
    };

    const _model = {
        create: (clase, data) => new win[clase](data),
        define: (nombreClase, props, functions) => {
            const propiedades_Clase = o.keys(props);
            const funciones = o.keys(functions);
                
            win[nombreClase] = (new Function('parametros_NuevaInstancia', 'return (props_Clase, funcion_Constructor) => { \
                return function ' + nombreClase + ' (parametros_NuevaInstancia) { \
                    let obj = this; \
                    props_Clase.forEach((key) => obj[key] = parametros_NuevaInstancia[key]); \
                    funcion_Constructor.call(this); \
                    return obj; \
                }; \
            };')())(propiedades_Clase, functions.constructor);

            funciones.forEach((key) => win[nombreClase].prototype[key] = functions[key]);

            const extend = function (name, props, functions) {

                const ext = (el, opt) => {
                    for (const n in opt)
                        el[n] = opt[n];
                    return el;
                };

                functions = functions || {};

                ext(props, this.props);
                ext(functions, this.functions);

                return _model.define(name, props, functions);
            }

            win[nombreClase].prototype.validate = function () { };

            return {
                extend: extend,
                props: props,
                functions: functions
            }
        }
    };

    const _watch = function (obj, prop, callback) {
        let oldValue = obj[prop]
            , newValue = oldValue
            , getter = () => newValue
            , setter = (value) => {
                oldValue = newValue;
                newValue = value;
                callback.call(obj, prop, oldValue, newValue);
            };
        if (delete obj[prop]) {
            o.defineProperty(obj, prop, {
                get: getter,
                set: setter,
                enumerable: true,
                configurable: true
            });
        }
        return this;
    };

    const _Request = (method, url, fn, data, contentType, includeAccept) => {
        const f = () => { };
        includeAccept = typeof includeAccept == 'boolean' ? includeAccept : true;
        fn = fn || {};

        let functions = {};
        functions['200'] =  fn.Ok || f;
        functions['201'] =  fn.Created || f;
        functions['204'] =  fn.NoContent || f;
        functions['302'] =  fn.Moved || f;
        functions['400'] =  fn.BadRequest || f;
        functions['401'] =  fn.Unauthorized || f;
        functions['404'] =  fn.NotFound || f;
        functions['500'] = 
        functions['0'] =    fn.InternalServerError || f;
        functions['504'] =  fn.GatewayTimeout || f;
        functions['408'] =  () => alert('No se puede establecer comunicación con el servidor');
        functions['409'] =  () => {
            alert('Se cerrará esta sesión porque el usuario ha ingresado en otro dispositivo');
            win.location.href = 'login.aspx';
        };
        functions['412'] =  () => {
            console.log('Posiblemente la sesión no se comparte entre el marco y el módulo');
            if (!alerta) {
                alerta = true;
                alert('No existe Sesión');
            }
            win.location.href = 'login.aspx';
        };

        const types = {
            JSON: 'application/json; charset=utf-8',
            XML: 'application/xml; charset=utf-8',
            TEXT: 'text/plain; charset=utf-8',
            DEFAULT: 'application/x-www-form-urlencoded'
        };

        const _exec = (fn, text, viewContent) => {
            if (viewContent) {
                switch (contentType.toUpperCase()) {
                    case 'JSON':
                    case 'DEFAULT':
                        text = JSON.tryParse(text);
                        break;
                    case 'XML':
                        text = _parseXml(text);
                        break;
                }
            }

            fn(text);
        };

        contentType = contentType || 'json';

        let http = new XMLHttpRequest();
        http.open(method, url, true);

        if (includeAccept === true) {
            http.setRequestHeader('Accept', 'application/json, text/javascript');
        }

        http.setRequestHeader('Content-type', types.hasOwnProperty(contentType.toUpperCase()) ? types[contentType.toUpperCase()] : contentType);

        const header = Request.headersConfig.find((header) => url.toLowerCase().startsWith(header.url.toLowerCase()));

        if (header != undefined) {
            http.setRequestHeader(header.type, header.value);
        }

        let alerta;
        const __switch = [200, 201];

        http.onreadystatechange = () => {
            if (http.readyState == 4) {
                _exec( functions[http.status], http.responseText, __switch.contains(http.status) );
            }
        };
        if (data) {
            if (contentType.toUpperCase() == 'DEFAULT') {
                let params = [];
                for (const attr in data) {
                    if (data[attr] instanceof Array) {
                        if (!!data[attr].length) {
                            data[attr].forEach((d) =>
                                params.push(s.format('{0}={1}', attr, encodeURIComponent(d))));
                        }
                        else {
                            params.push(s.format('{0}={1}', attr, ''));
                        }
                    }
                    else {
                        params.push(s.format('{0}={1}', attr, encodeURIComponent(data[attr])));
                    }
                }
                http.send(params.join('&'));
            }
            else if (contentType.toUpperCase() == 'TEXT') {
                http.send(data);
            }
            else {
                http.send(JSON.stringify(data));
            }
        }
        else
            http.send();

        return http;
    };

    o.defineProperty(_Request, 'headersConfig', {
        value: [],
        enumerable: false,
        configurable: false
    });

    _Request.setHeader = (url, type, value) => _Request.headersConfig.push({ url: url, type: type, value: value });

    module.exports = {
        toAESEncrypt: function (text, __noiterar) {
            if (typeof CryptoJS === 'undefined') {
                throw new SincoInitializationError('¡Falta la referencia de AES.js!');
            }

            let key = CryptoJS.enc.Utf8.parse(String.concat(String.fromCharCode(53), String.fromCharCode(49), String.fromCharCode(110),
                String.fromCharCode(99), String.fromCharCode(48), String.fromCharCode(115), String.fromCharCode(111),
                String.fromCharCode(102), String.fromCharCode(116), String.fromCharCode(95), String.fromCharCode(53),
                String.fromCharCode(46), String.fromCharCode(65), String.fromCharCode(46), String.fromCharCode(53),
                String.fromCharCode(46))); //Mismo KEY usado en C#

            const iv = CryptoJS.enc.Utf8.parse(String.concat(String.fromCharCode(95), String.fromCharCode(84), String.fromCharCode(49),
                String.fromCharCode(99), String.fromCharCode(115), String.fromCharCode(124), String.fromCharCode(70),
                String.fromCharCode(111), String.fromCharCode(110), String.fromCharCode(42), String.fromCharCode(53),
                String.fromCharCode(111), String.fromCharCode(95), String.fromCharCode(83), String.fromCharCode(52),
                String.fromCharCode(53))); //Mismo IV usado en C#
    
            const valorIterar = !!__noiterar ? 0 : Math.floor((Math.random() * 9) + 1);
    
            let iterar = (final, text, key, iv) => {
                let textoCrypto;
    
                textoCrypto = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(text), key,
                    {
                        keySize: 16,
                        iv: iv,
                        mode: CryptoJS.mode.CBC,
                        padding: CryptoJS.pad.Pkcs7
                    });
                if (final > 0) {
                    return iterar(final - 1, textoCrypto, key, iv);
                } else {
                    return textoCrypto;
                }
            }
    
            return iterar(valorIterar, text, key, iv).toString() + (valorIterar > 0 ? valorIterar : '');
        },
        fromAESEncrypt: function(text) {
            if (typeof CryptoJS === 'undefined') {
                throw new SincoInitializationError('¡Falta la referencia de AES.js!');
            }

            let key = CryptoJS.enc.Utf8.parse(String.concat(String.fromCharCode(53), String.fromCharCode(49), String.fromCharCode(110),
                String.fromCharCode(99), String.fromCharCode(48), String.fromCharCode(115), String.fromCharCode(111),
                String.fromCharCode(102), String.fromCharCode(116), String.fromCharCode(95), String.fromCharCode(53),
                String.fromCharCode(46), String.fromCharCode(65), String.fromCharCode(46), String.fromCharCode(53),
                String.fromCharCode(46))); //Mismo KEY usado en C#

            const iv = CryptoJS.enc.Utf8.parse(String.concat(String.fromCharCode(95), String.fromCharCode(84), String.fromCharCode(49),
                String.fromCharCode(99), String.fromCharCode(115), String.fromCharCode(124), String.fromCharCode(70),
                String.fromCharCode(111), String.fromCharCode(110), String.fromCharCode(42), String.fromCharCode(53),
                String.fromCharCode(111), String.fromCharCode(95), String.fromCharCode(83), String.fromCharCode(52),
                String.fromCharCode(53))); //Mismo IV usado en C#

            const valorIterar = parseInt( text.split('').pop() );

            let iterar = (final, text, key, iv) => {
                let textoCrypto;

                textoCrypto = CryptoJS.AES.decrypt(text, key,
                    {
                        keySize: 16,
                        iv: iv,
                        mode: CryptoJS.mode.CBC,
                        padding: CryptoJS.pad.Pkcs7
                    }).toString(CryptoJS.enc.Utf8);

                if (final > 0) {
                    return iterar(final - 1, textoCrypto, key, iv);
                } else {
                    return textoCrypto;
                }
            }
    
            return iterar(valorIterar, text.substring(0, text.length - 1), key, iv).toString();
        }
    }
});